---
layout:        post
title:         "Codeforces Round #544 (Div. 3)"
subtitle:      "Codeforces Round #544 (Div. 3)"
author:        "hongzhiyin"
header-style:  text
mathjax:       true
catalog:       true
tags:
  - 逐火之蛾
  - Codeforces
---

[Codeforces Round #544 (Div. 3)](http://codeforces.com/contest/1133) 

### [A. Middle of the Contest](http://codeforces.com/contest/1133/problem/A) 

**题意** 

求两个时间段的中点。

**代码** 

```c++
/* <<head>> */ 
// ------- 变量 ------- //
 
int h1, m1, h2, m2;
 
// ------- 函数 ------- //
 
void Init() {
    scanf("%d:%d%d:%d", &h1, &m1, &h2, &m2);
}
 
int Solve() {
    int a = h1 * 60 + m1;
    int b = h2 * 60 + m2;
    int c = b - a >> 1;
    a += c;
    return printf("%02d:%02d\n", a/60, a%60);
}
```



---



### [B. Preparation for International Women's Day](http://codeforces.com/contest/1133/problem/B) 

**题意**

$n$ 个数，最多能分多少组，使得每组两个数，且两个数相加可被 $k$ 整除。

**代码** 

```c++
/* <<head>> */
const int N = (int)1e5+7;

// ------- 变量 ------- //

int n, k;
int cnt[107];

// ------- 函数 ------- //

void Init() {
    scanf("%d%d", &n, &k);
    rep(i, 0, n) {
        int x; scanf("%d", &x);
        cnt[x%k]++;
    }
}

int Solve() {
    ll ans = 0;
    rep(i, 1, (k+1)/2) ans += min(cnt[i], cnt[k-i]);
    if (~k & 1) ans += cnt[k/2] / 2;
    ans += cnt[0] / 2;
    return printf("%lld\n", ans << 1);
}
```



---



### [C. Balanced Team](http://codeforces.com/contest/1133/problem/C) 

**题意** 

$n$ 个数，选尽可能多的数，使得两两差值不超过 $5$ 。

**代码** 

```c++
/* <<head>> */
const int N = (int)2e5+7;

// ------- 变量 ------- //

int n, a[N];

// ------- 函数 ------- //

void Init() {
    scanf("%d", &n);
    rep(i, 0, n) scanf("%d", a+i);
}

int Solve() {
    sort(a, a + n);
    int ans = -INF, r = 1;
    rep(l, 0, n) {
        while (r < n && a[r] - a[l] <= 5) r++;
        ans = max(ans, r - l);
    }
    return printf("%d\n", ans);
}
```



---



### [D. Zero Quantity Maximization](http://codeforces.com/contest/1133/problem/D) 

**题意** 

$n$ 个数 $a[\ ]$ 和 $n$ 个数 $b[\ ]$ ，令 $c[i] = d \cdot a[i] + b[i]$ ，求：当选择最优的 $d$ 时， $c[\ ]$ 中最多有多少个 $0$ 。

**题解** 

推导出 $\large d = -\frac{b[i]}{a[i]}$ ，用 $map$ 记录。

特判 $a[i] = 0$ 的情况，累加到答案。

**代码** 

```c++
/* <<head>> */
const int N = (int)2e5+7;

// ------- 变量 ------- //

int n, a[N], b[N];
map <pii, int> M;

// ------- 函数 ------- //

pii work(int a, int b) {
    int g = __gcd(a, b);
    a /= g; b /= g;
    if (a < 0) return mp(-a, -b);
    return mp(a, b);
}

void Init() {
    scanf("%d", &n);
    
    M.clear();
    rep(i, 1, n+1) scanf("%d", a+i);
    rep(i, 1, n+1) scanf("%d", b+i);
}

int Solve() {
    int ans = 0, num = 0;
    rep(i, 1, n+1) num += (a[i] == 0 && b[i] == 0);
    rep(i, 1, n+1) {
        if (a[i] == 0) continue;
        int tmp = ++M[work(a[i], b[i])];
        ans = max(ans, tmp);
    }
    return printf("%d\n", ans + num);
}
```



---



### [E. K Balanced Teams](http://codeforces.com/contest/1133/problem/E) 

**题意** 

$n$ 个数分 $k$ 组，每组内极差不超过 $5$ ，求最多有多少个数可被分到组内。

**题解** 

1. 从小到大排序，分组一定为若干段。

2. 预处理 $pre[i]$ 表示第 $i$ 个数向左最长延伸多长。

3. $dp[i][j]$ 表示前 $i$ 个数，分 $j$ 组的答案，转移有：

   1. 不使用第 $j$ 个数：

      $dp[i][j] = dp[i-1][j]$ 

   2. 以第 $j$ 个数作为最后一组的最后一个数：

      $dp[i][j] = dp[i-pre[i]][j-1] + pre[i]$ 

4. 边界情况： $i-pre[i]$ 可能会小于 $j-1$ 

5. 当 $dp[i][j]$ 的 $i$ 小于 $j$ 时，答案即为 $i$ 

**代码** 

```c++
/* <<head>> */
const int N = (int)5e3+7;
 
// ------- 变量 ------- //
 
int n, k, a[N], pre[N], dp[N][N];
 
// ------- 函数 ------- //
 
void Init() {
    scanf("%d%d", &n, &k);
    memset(dp, 0, sizeof(dp));
 
    rep(i, 1, n+1) scanf("%d", a+i);
    sort(a + 1, a + n + 1);
}
 
int Solve() {
    int l = 1;
    rep(r, 1, n+1) {
        while (a[r] - a[l] > 5) l++;
        pre[r] = r - l + 1;
    }
    rep(i, 1, n+1) rep(j, 1, k+1) {
        if (i <= j) dp[i][j] = i;
        else dp[i][j] = max(dp[i-1][j], dp[i-pre[i]][j-1] + pre[i]);
    }
    return printf("%d\n", dp[n][k]);
}
```



---



