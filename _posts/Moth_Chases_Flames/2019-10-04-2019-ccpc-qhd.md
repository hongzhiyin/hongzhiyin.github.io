---
layout:        post
title:         "2019 CCPC 秦皇岛"
subtitle:      "2019 CCPC Qinhuangdao Onsite"
author:        "hongzhiyin"
header-style:  text
mathjax:       true
catalog:       true
tags:
  - CCPC
  - 逐火之蛾
---

[2019 CCPC 秦皇岛](https://cn.vjudge.net/contest/331552)

### A



---

### B



---

### C



---


### [D. Decimal](https://codeforces.com/gym/102361/problem/D) 

**题意** 

输入 $n$ ，判断 $\frac{1}{n}$ 是否为无限小数。

$1 \le n \le 100$

**题解** 

1. 设 $x = \frac{1}{n}$ 是有限的 $k$ 位小数，则
   
   $$
   x \cdot 10^{k} = 10^k /\ n
   $$
   
2. $x \cdot 10^k$ 等于多少不重要，但可以确定是一个整数，则
   
   $$
   10^k\ \%\ n = 0
   $$
   
3. $a$ 可以被 $b$ 整除，则 $b$ 的质因子集合是 $a$ 的质因子集合的子集。

   1. 质因子集合是一个可重集合
   2. 集合中质因子的出现次数等于其在唯一分解中的指数

4. $10 ^ k$ 的质因子集合中，只出现质因子 $2$ 和 $5$ ，可出现 $0$ 次到无限次。

5. 则 $n$ 的质因子集合中，应只能出现 $2$ 和 $5$ 。

**代码** 

```c++
/* <<head>> */
// ------- 变量 ------- //

int n;

// ------- 函数 ------- //

void Init() {
    scanf("%d", &n);
}

int Solve() {
    while (n % 2 == 0) n /= 2;
    while (n % 5 == 0) n /= 5;
    return puts(n == 1 ? "No" : "Yes");
}
```



---


### E



---


### [F. Forest Program](https://codeforces.com/gym/102361/problem/F) 

**题意** 

$n$ 个点 $m$ 条边，保证所有连通分量都是仙人掌。

求 “ 删掉若干条边使得剩下的所有连通分量都是树 ” 的方案数。

仙人掌：无自环、无重边的无向连通图，任意一条边，最多属于一个简单环。

定义两个方案不同，当且仅当删掉的边集不同。

$1 \le n \le 300000$ 

$0 \le m \le 500000$ 

**题解** 

1. 图中所有简单环，至少需要删掉一条边。

2. 不在环上的边，可删可不删。

3. 若共有 $c$ 个环，第 $i$ 个环上有 $a_i$ 条边，不在环上的边有 $b$ 条，则方案数为：
   
   $$
   \large 2^b \cdot \prod_{i=1}^{c}(2^{a_i}-1)
   $$
   
4. 如何求仙人掌图中有多少个环，以及每个环的大小

   1. 仙人掌图中的每个环，即为一个点双连通分量，可直接套用模板 $DCC$ 求解。
   2. 直接用 $dfs$ 遍历，记录节点深度。当遍历到已经走过的节点时，即为环。环的大小用两点深度相减即可。

5. 注意图可能非连通。

**代码** 

**dfs** 

```c++
/* <<head>> */
const int MOD = 998244353;
const int N = 3e5+7;

// ------- 变量 ------- //

int n, m;
vi e[N];
int ans;
 
// ------- 函数 ------- //
 
inline int add(int a, int b) { return (a += b) >= MOD ? a - MOD : a; }
inline int mul(int a, int b) { return 1ll * a * b % MOD; }
inline int qpow(ll a, ll b) {
    int r = 1;
    for (; b; a = a * a % MOD, b >>= 1)
        if (b & 1) r = 1ll * r * a % MOD;
    return r;
}
 
int dep[N];
void dfs(int u, int f=0) {
    dep[u] = dep[f] + 1;
    for (auto v : e[u]) if (v != f) {
        if (!dep[v]) {
            dfs(v, u);
        } else if (dep[u] > dep[v]) {
            m -= dep[u] - dep[v] + 1;
            ans = mul(ans, add(qpow(2, dep[u] - dep[v] + 1), MOD-1));
        }
    }
}
 
void Init() {
    ans = 1;
 
    scanf("%d%d", &n, &m);
    rep(i, 1, n+1) e[i].clear();
    rep(i, 0, m) {
        int u, v; scanf("%d%d", &u, &v);
        e[u].pb(v); e[v].pb(u);
    }
}
 
int Solve() {
    rep(i, 1, n+1) if (!dep[i]) dfs(i);
    ans = mul(ans, qpow(2, m));
    return printf("%d\n", ans);
}
```



**点双连通分量** 

注意：孤立点和孤立边也是点双分量，但它们不是环。

```c++
/* <<head>> */
const int MOD = 998244353;
const int N = 3e5+7;
 
// ------- 变量 ------- //
 
int n, m;
vi e[N];
int ans;
 
// ------- 函数 ------- //
 
inline int add(int a, int b) { return (a += b) >= MOD ? a - MOD : a; }
inline int mul(int a, int b) { return 1ll * a * b % MOD; }
inline int qpow(ll a, ll b) {
    int r = 1;
    for (; b; a = a * a % MOD, b >>= 1)
        if (b & 1) r = 1ll * r * a % MOD;
    return r;
}
 
vi Dcc[N], e2[N<<1];
int dfn[N], low[N], cut[N], id[N], dcc[N], S[N], top, cnt, num, no;
struct Vertex_Biconnected_Component {
    void DCC(int u, int rt) {
        dfn[u] = low[u] = ++no;
        S[top++] = u;
        if (e[u].empty()) { Dcc[++cnt].pb(u); return ; }
        int son = 0;
        for (auto v : e[u]) {
            if (!dfn[v]) {
                DCC(v, rt);
                low[u] = min(low[u], low[v]);
                if (low[v] >= dfn[u]) {
                    son++;
                    if (u != rt || son > 1) cut[u] = 1;
                    cnt++;
                    do { Dcc[cnt].pb(S[--top]); } while (S[top] != v);
                    Dcc[cnt].pb(u);
                }
            } else {
                low[u] = min(low[u], dfn[v]);
            }
        }
    }
    void run(int n) {
        no = top = cnt = 0;
        memset(dfn, 0, sizeof(dfn[0]) * (n+1));
        memset(cut, 0, sizeof(cut[0]) * (n+1));
        rep(i, 1, n+1) Dcc[i].clear();
        rep(i, 1, n+1) if (!dfn[i]) DCC(i, i);
        num = cnt;
        rep(i, 1, n+1) if (cut[i]) id[i] = ++num;
        rep(i, 1, num+1) e2[i].clear();
        rep(i, 1, cnt+1) for (auto o : Dcc[i]){
            if (cut[o]) { e2[i].pb(id[o]); e2[id[o]].pb(i); }
            else dcc[o] = i;
        }
    }
} vbc;
 
void Init() {
    ans = 1;
 
    scanf("%d%d", &n, &m);
    rep(i, 1, n+1) e[i].clear();
    rep(i, 0, m) {
        int u, v; scanf("%d%d", &u, &v);
        e[u].pb(v); e[v].pb(u);
    }
}
 
int Solve() {
    vbc.run(n);
    rep(i, 1, cnt+1) {
        if (sz(Dcc[i]) < 3) continue;  // 孤立点和孤立边也是点双分量，但它们不是环
        ans = mul(ans, add(qpow(2, sz(Dcc[i])), MOD-1));
        m -= sz(Dcc[i]);
    }
    ans = mul(ans, qpow(2, m));
    return printf("%d\n", ans);
}
```





---


### G



---


### H



---


### I



---


### J



---


### K



---


### L



---
